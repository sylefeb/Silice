// SL 2023-04-17 @sylefeb
// ========================================================
//
// This SOC runs entirely in PSRAM, enabling to use a
//  'large' RAM for the CPU.
//
// It's been shown to be Doom-capable :)
//
// This is using a special verision of the ice-v RV32I,
// see CPUs/ice-v-ram.si
//
// The SOC is meant to fit in the IceStick and features:
// - the QSPI RAM controler for a SPRAM module
//   (see ../qpsram)
// - a SPIscreen
// - UART sending (e.g. for printf)
//
// ========================================================
//
// IMPORTANT: Assumes QSPI memory is already initialized.
//            User xfer tool in ../qpsram
//
// ========================================================
// https://github.com/sylefeb/Silice
// MIT license, see LICENSE_MIT in Silice repo root
// ========================================================

// Address space and boot configuration
// allow for 32MB RAM addressing + 1 bit periph
// (addressing 32bits: 2^23 x 32bits, 8MB x 4 bytes)
$$addrW    = 24 -- 23 bits for addresses, 1 bit for peripheral mapping
// bit for peripheral addresses
$$periph   = addrW-1
// boot address in QQSPI
$$Boot     = 0
$$print('===========> address bus width: ' .. addrW)

$$if SIM_SB_IO then
append('ice40_sb_io_sim.v')
import('passthrough.v')
$$end

// Main design frequency
$$if SIM_SB_IO then
$$master_freq = 25
$$else
$$master_freq = 50
$$end

$$if ICESTICK then
// Import hardware modules
import('../common/plls/icestick_$master_freq$_lock.v')
$$elseif SIMULATION then
// Import SPRAM simulation
$include('../../common/simulation_spram.si')
$$else
$$error('uho, this SOC is for simulation or IceStick only')
$$end

$$if NO_FASTRAM then
$$print('===========> Building without fastram')
$$end

$$if SPISCREEN_EXTRA then
$$  SPISCREEN=1
$$end

// Include the processor
$$ICEV_FAST_SHIFT = nil
$$ICEV_MULDIV     = nil
$$ICEV_USERDATA   = nil
$include('../CPUs/ice-v-ram.si')

// Include the QSPRAM controller
$include('old_qpsram2x.si') // NOTE: uses an older version as new one is larger
                            //       FIXME TODO

// Include the UART controller
$$uart_bauds = 115200
$$uart_in_clock_freq_mhz = master_freq
$include('../common/uart.si')

$include('../common/clean_reset.si')

// --------------------------------------------------
// RAM
// --------------------------------------------------

// This group holds the signals for the 32-bits RAM ios
group ram_io {
  uint$addrW$ addr(0),     // addr to read from / write to
  uint1       wenable(0),  // write enable
  uint3       byte_size(0),   // byte size (1,2,4)
  uint2       byte_offset(0), // byte offset
  uint32      wdata(0),    // 4-bytes to write
  uint32      rdata(0),    // 4-bytes read from memory
  uint1       req_valid(0),// memory request ready (pulse)
  uint1       done(0),     // memory request done (pulse)
}

// memory provider interface (user interface defined in processor source)
interface ram_provider {
  input     addr,
  input     wenable,
  input     byte_size,
  input     byte_offset,
  input     wdata,
  output    rdata,
  input     req_valid,
  output    done
}

// --------------
// QQSPI implementation of a ROM
unit qqspi_memory(
  ram_provider io,
  inout   uint1 ram_io0,  inout  uint1 ram_io1,
  inout   uint1 ram_io2,  inout  uint1 ram_io3,
  output  uint1 ram_clk,  output uint1 ram_csn,
  output  uint2 ram_bank,
) {
  $$if SIMULATION then
  uint32 cycle(0);
  uint32 cycle_req(0);
  $$end
  // QPSRAM RAM
  qpsram_ram ram(
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
  );
  // logic
  uint1            ram_was_busy(0);
  uint1            fastram_was_busy(0);
  uint4            work_vector(0);
  uint2            count(0);
  uint32           wdata(0);
  // fastram
$$if not NO_FASTRAM then
  bram uint8       fastram[2048] = uninitialized;
$$end
  always {
    ram.init      = 0;
    // in periph?
    uint1 in_periph         = io.addr[$addrW-3$,3] == 3b100;
    // in fastram?
$$if not NO_FASTRAM then
    uint1 in_fastram        = &io.addr[$addrW-3$,3]; //_ == 3b111
$$else
    uint1 in_fastram        = 0; // no fastram, always 0
$$end
    // mask request on peripherals
    uint1 req_valid         = io.req_valid & ~in_periph;
$$if not NO_FASTRAM then
    uint1 req_valid_ram     = req_valid    & ~in_fastram;
    uint1 req_valid_fastram = req_valid    &  in_fastram;
$$else
    uint1 req_valid_ram     = req_valid;
    uint1 req_valid_fastram = 0;// no fastram, always 0
$$end
    // data being read
    io.rdata[{count,3b0},8] = (ram.data_next  ? ram.rdata               : 8b0)
$$if not NO_FASTRAM then
            | (in_fastram                     ? fastram.rdata           : 8b0)
$$end
            | ((~ram.data_next & ~in_fastram) ? io.rdata[{count,3b0},8] : 8b0);
    // data being written
    ram.wdata     = wdata[0,8];
    // NOTE: ^^^^^^^^^^^^ wdata is not needed immediately by ram which is why it
    //       is passed above to ram with latency wrt. assignment below vvvvvv
    wdata        = (ram.data_next | (in_fastram&~io.req_valid) ) ? {8b0,wdata[8,24]}
                 : req_valid                                     ? io.wdata
                 : wdata;
$$if not NO_FASTRAM then
    fastram.wdata = wdata[0,8];
$$end
    // address
$$if SIMULATION then
    ram.addr     = req_valid_ram ? {io.addr,io.byte_offset} : ram.addr;
$$else
    ram.addr     = req_valid_ram ? {io.addr[0,$addrW-3$],io.byte_offset} : ram.addr;
    ram_bank     = io.addr[$addrW-3$,2];
$$end
$$if not NO_FASTRAM then
    fastram.addr    = req_valid_fastram ? {io.addr[0,9],io.byte_offset} : (fastram.addr+1);
    fastram.wenable = req_valid_fastram ? io.wenable : (fastram.wenable & (work_vector!=0));
$$end
    ram.wenable     = req_valid_ram     ? io.wenable : ram.wenable;
    // count bytes
    count        = (req_valid                 ) ? 0
                 : (ram.data_next | in_fastram) ? (count+1) : count;
    // one bit per byte to read/write
    uint4 work_init = (io.byte_size[1,1] ? 3b001 : 3b000)
                    | (io.byte_size[2,1] ? 3b100 : 3b000);
    work_vector  =
    req_valid ?
              ((ram.wenable|(in_fastram & ~io.wenable)) ? {work_init,in_fastram}
//                 |                                                    ^
/* ram writes need one more step */                     : work_init) // |
/*                          one more cycle for reads -------------------|     */
              : (ram.data_next | in_fastram) ? {1b0,work_vector[1,3]} // shift
              : work_vector; // keep
    // done?
    io.done      = (ram_was_busy & ~ram.busy)
                 | (io.req_valid & in_periph)
$$if not NO_FASTRAM then
                 | (fastram_was_busy & in_fastram & (work_vector==0))
$$end
                 ;
    ram_was_busy     = ram.busy | req_valid_ram;
$$if not NO_FASTRAM then
    fastram_was_busy = io.req_valid ? in_fastram
                                    : (io.done ? 0 : fastram_was_busy);
$$end
    // keep going?
    ram.in_ready = ((work_vector != 0) & ram.in_ready) | req_valid_ram;
$$if SIMULATION then
    /*
    if (io.req_valid) {
      cycle_req   = cycle;
      if (in_fastram) {
        if (io.wenable) {
          __display("[%d][req ] **** [W] fastram:%b, wenable %b, offset %d, size %d, work_vector %b, ram.addr @%x, wdata: %x, bank:%b",cycle,in_fastram,io.wenable,io.byte_offset,io.byte_size,work_vector,ram.addr,io.wdata,ram_bank);
        } else {
          __display("[%d][req ] **** [R] fastram:%b, work_vector %b, offset %d, size %d, addr @%x, bank:%b ------------------------------------------",cycle,in_fastram,work_vector,io.byte_offset,io.byte_size,ram.addr,ram_bank);
        }
      }
    }
    if (ram.data_next) {
      //__display("[%d][next] work_vector:%b count:%d ram.in_ready:%b ram.wenable:%b",cycle,work_vector,count,ram.in_ready,ram.wenable);
    }
    if (in_fastram) {
      __display("[%d][next] work_vector:%b count:%d io.byte_size:%d fastram.wenable:%b fastram.addr:%x fastram.rdata:%x fastram.wdata:%x",cycle,work_vector,count,io.byte_size,fastram.wenable,fastram.addr,fastram.rdata,fastram.wdata);
    }
    if (io.done) {
      __display("[%d][req ] RAM req done in %d cycles (rdata:%x)",cycle,cycle-cycle_req+1,io.rdata);
    }
    */
    cycle = cycle + 1;
$$end

  }
}

// --------------------------------------------------
// PLL for simulation
// --------------------------------------------------

$$if SIMULATION then
algorithm pll(
  output! uint1 clock4x,
  output  uint1 clock2x,
  output  uint1 clock1x,
) <autorun> {
  uint2 counter(0);
  clock4x := clock;
  clock2x := ~counter[0,1]; // x2 slower
  clock1x := ~counter[1,1]; // x4 slower
  always { counter = counter + 1; }
}
$$end

// --------------------------------------------------
// SOC
// --------------------------------------------------

unit main( // I guess this is the SOC :-D
  output uint5 leds,
$$if PMOD_QQSPI then
  inout   uint1 ram_io0,
  inout   uint1 ram_io1,
  inout   uint1 ram_io2,
  inout   uint1 ram_io3,
  output  uint1 ram_clk,
  output  uint1 ram_csn,
  output  uint2 ram_bank,
$$end
$$if UART then
  output  uint1 uart_tx,
  input   uint1 uart_rx,
$$end
$$if SPISCREEN then
  output  uint1 spiscreen_clk,
  output  uint1 spiscreen_mosi,
  output  uint1 spiscreen_dc,
  output  uint1 spiscreen_resn,
  output  uint1 spiscreen_csn(0),
$$if VERILATOR then
  output uint2  spiscreen_driver(2/*ST7789*/),
  output uint10 spiscreen_width (320),
  output uint10 spiscreen_height(240),
$$end
$$end
)
$$if ICESTICK then
$$if not SIM_SB_IO then
<@fastclk,!rst> {
  // ---- clocking (pll)
  uint1 fastclk = uninitialized;
  uint1 rst     = uninitialized;
  pll pllgen(
    clock_in  <: clock,
    clock_out :> fastclk,
    rst       :> rst,
  );
$$else
{
  uint1 fastclk = uninitialized;
  passthrough _(inv <: clock, outv :> fastclk);
$$end
$$else
{
  uint32 cycle(0);
  // dummy pins for simulation
  uint1 ram_io0(0);  uint1 ram_io1(0);  uint1 ram_io2(0);
  uint1 ram_io3(0);  uint1 ram_clk(0);  uint1 ram_csn(0);
  uint2 ram_bank(0);
$$end

  // ---- display SPI controller
$$if SPISCREEN then
  uint1 screen_dc(0);   uint1 screen_clk(0);
  uint1 screen_mosi(0); uint1 screen_resn(0);
  uint1 displ_dta_or_cmd <: ~ramio.wdata[9,1]; // data or command
  uint8 displ_byte       <:  ramio.wdata[0,8]; // byte to be written
  spi_mode3_send display(
    data_or_command <: displ_dta_or_cmd,
    byte            <: displ_byte,
    spi_mosi        :> screen_mosi,
    spi_clk         :> screen_clk,
    spi_dc          :> screen_dc,
  );
$$if not SIMULATION then
   sb_io _( clock <: fastclk, out  <: screen_clk,  pin  :> spiscreen_clk);
   sb_io _( clock <: fastclk, out  <: screen_mosi, pin  :> spiscreen_mosi);
   sb_io _( clock <: fastclk, out  <: screen_dc,   pin  :> spiscreen_dc);
   sb_io _( clock <: fastclk, out  <: screen_resn, pin  :> spiscreen_resn);
$$end
$$end

  // ---- memory
  ram_io ramio;
  qqspi_memory ram(
    io      <:> ramio,
    ram_csn  :> ram_csn,    ram_clk  :> ram_clk,
    ram_io0 <:> ram_io0,    ram_io1 <:> ram_io1,
    ram_io2 <:> ram_io2,    ram_io3 <:> ram_io3,
    ram_bank :> ram_bank
  );

  // ---- cpu
  icev_ram cpu(
    mem <:> ramio,
  );

  // ---- uart
  uart_out    uo;
$$if UART then
  uart_sender usend(
    io      <:> uo,
    uart_tx :>  uart_tx
  );
$$end

  // ---- always block (main logic)
  always {

    // ---- peripherals
    // uart
    uo.data_in_ready = 0;  // maintain low
    uo.data_in       = ramio.wdata[0,8];
$$if SPISCREEN then
    // display
    display.enable   = 0;  // maintain low
$$if SIMULATION then
    spiscreen_clk  = screen_clk; spiscreen_mosi = screen_mosi; // assign pins
    spiscreen_dc   = screen_dc;  spiscreen_resn = screen_resn;
$$end
$$end
$$if TRACE then
    cpu.trace_on = reset ? 0 : cpu.trace_on;
$$end

    // ---- memory mapping to peripherals: writes
    // (vvvvvv NOTE: could register vvvvvv)
		if (ramio.req_valid & ramio.wenable & ramio.addr[$addrW-3$,3] == 3b100) {
      uint3 select = ramio.addr[0,3];
      onehot(select) {
        case 0: {
          // leds for activity
          leds = ramio.wdata[0,5];
$$if SIMULATION then
$$if not TRACE then
          __write("%c",ramio.wdata[0,8]);
$$else
          if (ramio.wdata[31,1]) {
            if (cpu.trace_on) {
              __finish();
            } else {
              cpu.trace_on  = 1;
            }
          }
$$end
          __verilog("$c32(\"output_char(\",%,\");\");",ramio.wdata[0,8]);
$$end
          // send over uart
          uo.data_in_ready = 1;
        }
        case 1: {
$$if SPISCREEN then
          // command
          display.enable = 1;
$$if SIMULATION then
          //__display("[cycle %d] SPISCREEN: %b %x (cmd:%b)", cycle, ramio.wdata[0,8], ramio.wdata[0,8], ramio.wdata[9,1]);
$$end
$$end
        }
        case 2: {
$$if SPISCREEN then
          // reset
          screen_resn    = ~ ramio.wdata[0,1];
$$if SIMULATION then
          // __display("[cycle %d] SPISCREEN resn: %b", cycle, ~ramio.wdata[0,1]);
$$end
$$end
        }
        default: { }
      }
    }

$$if SIMULATION then
    cycle       = cycle + 1;
    // if (cycle == 700) { __finish(); } // stops sim after n cycles
$$end
  }

}

// --------------------------------------------------

$$if SPISCREEN then
// include SPI driver for screen
$include('../common/spi.si')
$$end

// --------------------------------------------------
